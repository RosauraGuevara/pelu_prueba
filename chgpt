Necesito que en base a los horarios de atención configurados desde el panel de administración y la duración del servicio elegido se pueda elegir una fecha disponible y posteriormente una hora disponible dentro de esa fecha.
ejemplo: si el 16 de agosto es viernes y los viernes se atiende de 06 a 18, el servicio dura 3 horas y aún no hay citas debería poder seleccionarse esa fecha y posteriormente el horario entre las 06 y las 15, pero si ya hay una cita de una hora para las 06 debería poder seleccionarse solo las horas desde las 07 haste las 15.
deberían generarse fechas disponibles automaticamente desde el presente hasta unos 90 dias.
Actualmente cualquier fecha que elija me dice que no hay disponibilidad en esa fecha y eso no es cierto.
¿Podrias hacer que mi app cumpla con ese requisito?

Estos son los codigos hasta ahora así tal cual, no me digas que verifique tal y cual cosa dentro del codigo porque te los comparto todos y te pido que verifiques tu y que crees el codigo con los cambios necesarios.

raíz/app.py
from flask import Flask, flash, render_template, request, redirect, url_for, jsonify
from flask_sqlalchemy import SQLAlchemy
from dotenv import load_dotenv
import os
from datetime import datetime, timedelta, date, time
from flask_migrate import Migrate

load_dotenv()

app = Flask(__name__)
app.secret_key = os.getenv('SECRET_KEY')

app.config['SQLALCHEMY_DATABASE_URI'] = os.getenv('DATABASE_URL')
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
db = SQLAlchemy(app)
migrate = Migrate(app, db)

class Cliente(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    email = db.Column(db.String(100), nullable=False, unique=True)
    telefono = db.Column(db.String(15), nullable=False)
    direccion = db.Column(db.String(200), nullable=False)  
    cumpleanos = db.Column(db.Date, nullable=False)
    lugar = db.Column(db.String(20), nullable=False)
    pago = db.Column(db.String(20), nullable=False)

class Cita(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    cliente_id = db.Column(db.Integer, db.ForeignKey('cliente.id'), nullable=False)
    servicio = db.Column(db.String(100), nullable=False)
    fecha = db.Column(db.Date, nullable=False)
    hora = db.Column(db.Time, nullable=False)
    lugar = db.Column(db.String(20), nullable=False)

    cliente = db.relationship('Cliente', backref=db.backref('citas', lazy=True))

class horario_atencion(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    dia = db.Column(db.Date, nullable=False)  # lunes, martes, etc.
    hora_apertura = db.Column(db.Time, nullable=False)  # Ej. "09:00"
    hora_cierre = db.Column(db.Time, nullable=False)  # Ej. "22:00"

class Servicio(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    nombre = db.Column(db.String(100), nullable=False)
    duracion = db.Column(db.Integer, nullable=False)  # Duración en minutos

class Fecha_disponible(db.Model):
    id = db.Column(db.Integer, primary_key=True)
    fecha = db.Column(db.Date, nullable=False)
    dia_semana = db.Column(db.String(10), nullable=False)
    disponible = db.Column(db.Boolean, default=True)


def calcular_horas_ocupadas(citas_en_fecha):
    horas_ocupadas = []
    for cita in citas_en_fecha:
        hora_cita = datetime.combine(datetime.today(), cita.hora)
        servicio_cita = Servicio.query.filter_by(nombre=cita.servicio).first()
        duracion_cita = timedelta(minutes=servicio_cita.duracion)
        hora_fin_cita = hora_cita + duracion_cita
        horas_ocupadas.append((hora_cita, hora_fin_cita))
    return horas_ocupadas

def calcular_horas_disponibles(hora_apertura_str, hora_cierre_str, intervalo):
    # Convertir las cadenas de texto a objetos datetime.time
    hora_apertura = datetime.strptime(hora_apertura_str, '%H:%M').time()
    hora_cierre = datetime.strptime(hora_cierre_str, '%H:%M').time()

    horas_disponibles = []
    hora_actual = datetime.combine(datetime.today(), hora_apertura)
    hora_final = datetime.combine(datetime.today(), hora_cierre)

    while hora_actual <= hora_final:
        horas_disponibles.append(hora_actual.time())
        hora_actual += intervalo

    return horas_disponibles

@app.route('/')
def index():
    return render_template('index.html')

@app.route('/agendar', methods=['POST'])
def agendar():
    nombre = request.form['nombre']
    email = request.form['email']
    telefono = request.form['telefono']
    servicio = request.form['servicio']
    fecha = request.form['fecha']
    hora = request.form['hora']
    direccion = request.form['direccion']  
    cumpleanos = request.form['cumpleanos']
    lugar = request.form['lugar']
    pago = request.form['pago']
    
    try:
        cliente = Cliente.query.filter_by(email=email).first()
        if not cliente:
            cliente = Cliente(
                nombre=nombre,
                email=email,
                telefono=telefono,
                direccion=direccion,
                cumpleanos=datetime.strptime(cumpleanos, '%Y-%m-%d').date(),
                lugar=lugar,
                pago=pago
            )
            db.session.add(cliente)
            db.session.commit()
        
        cita = Cita(
            cliente_id=cliente.id, 
            servicio=servicio, 
            fecha=datetime.strptime(fecha, '%Y-%m-%d').date(),
            hora=datetime.strptime(hora, '%H:%M').time(),
            lugar=lugar
        )
        db.session.add(cita)
        db.session.commit()
    
        flash(f'Tu cita ha sido agendada correctamente para el {fecha} a las {hora}.', 'success')
    
    except Exception as e:
        flash(f'Hubo un error al agendar tu cita: {str(e)}', 'error')

    return redirect(url_for('confirmacion'))
    
@app.route('/confirmacion')
def confirmacion():
    return render_template('confirmacion.html')

@app.route('/admin')
def admin():
    citas = Cita.query.all()
    return render_template('admin.html', citas=citas)

@app.route('/citas', methods=['GET'])
def obtener_citas():
    fechas_disponibles = Fecha_disponible.query.all()
    citas = Cita.query.all()

    fechas_ocupadas = {}
    for fecha in fechas_disponibles:
        horario = horario_atencion.query.filter_by(dia=fecha.dia_semana).first()
        if horario:
            fecha_total_horas = calcular_horas_disponibles(horario.hora_apertura, horario.hora_cierre, timedelta(minutes=15))
            citas_en_fecha = [cita for cita in citas if cita.fecha == fecha.fecha]
            horas_ocupadas = calcular_horas_ocupadas(citas_en_fecha)

            if len(horas_ocupadas) >= len(fecha_total_horas):
                fechas_ocupadas[fecha.fecha] = "No disponible"
            else:
                fechas_ocupadas[fecha.fecha] = "Disponible"

    citas_json = []
    for fecha, estado in fechas_ocupadas.items():
        color = "red" if estado == "No disponible" else "green"
        citas_json.append({
            "title": estado,
            "start": f"{fecha}",
            "display": "background",
            "color": color
        })

    return jsonify(citas_json)

@app.route('/admin/horarios', methods=['GET', 'POST'])
def admin_horarios():
    if request.method == 'POST':
        dia = request.form['dia']
        hora_apertura = datetime.strptime(request.form['hora_apertura'], '%H:%M').time()
        hora_cierre = datetime.strptime(request.form['hora_cierre'], '%H:%M').time()

        horario = horario_atencion.query.filter_by(dia=dia).first()
        if horario:
            horario.hora_apertura = hora_apertura
            horario.hora_cierre = hora_cierre
        else:
            horario = horario_atencion(dia=dia, hora_apertura=hora_apertura, hora_cierre=hora_cierre)
            db.session.add(horario)

        hoy = date.today()
        fechas_agregadas = []
        for i in range(60):
            fecha_futura = hoy + timedelta(days=i)
            dia_semana = fecha_futura.strftime('%A').lower()
            if dia_semana == dia:
                fecha_formateada = fecha_futura.strftime('%Y-%m-%d')
                if not Fecha_disponible.query.filter_by(fecha=fecha_formateada).first():
                    nueva_fecha = Fecha_disponible(fecha=fecha_formateada, dia_semana=dia_semana)
                    db.session.add(nueva_fecha)
                    fechas_agregadas.append(fecha_formateada)

        db.session.commit()
        flash(f'Horario de {dia} actualizado y fechas futuras agregadas: {", ".join(fechas_agregadas)}.', 'success')
        return redirect(url_for('admin_horarios'))

    horarios = horario_atencion.query.all()
    return render_template('admin_horarios.html', horarios=horarios)

@app.route('/admin/servicios', methods=['GET', 'POST'])
def admin_servicios():
    if request.method == 'POST':
        nombre_servicio = request.form['nombre_servicio']
        duracion_servicio = int(request.form['duracion_servicio'])

        servicio_existente = Servicio.query.filter_by(nombre=nombre_servicio).first()
        if servicio_existente:
            flash(f'El servicio "{nombre_servicio}" ya existe.', 'error')
        else:
            nuevo_servicio = Servicio(nombre=nombre_servicio, duracion=duracion_servicio)
            db.session.add(nuevo_servicio)
            db.session.commit()
            flash(f'Servicio "{nombre_servicio}" agregado.', 'success')
        return redirect(url_for('admin_servicios'))

    servicios = Servicio.query.all()
    return render_template('admin_servicios.html', servicios=servicios)

@app.route('/admin/servicios/delete/<int:id>', methods=['POST'])
def eliminar_servicio(id):
    servicio = Servicio.query.get(id)
    if servicio:
        db.session.delete(servicio)
        db.session.commit()
        flash('Servicio eliminado con éxito.', 'success')
    else:
        flash('Servicio no encontrado.', 'error')
    return redirect(url_for('admin_servicios'))

@app.route('/admin/cancelar_cita/<int:id>', methods=['POST'])
def cancelar_cita(id):
    cita = Cita.query.get(id)
    if cita:
        db.session.delete(cita)
        db.session.commit()
        flash('Cita cancelada con éxito.', 'success')
    else:
        flash('Cita no encontrada.', 'error')
    return redirect(url_for('admin'))

@app.route('/horas_disponibles', methods=['POST'])
def obtener_horas_disponibles():
    data = request.get_json()
    fecha = data.get('fecha')
    servicio_id = data.get('servicio_id')

    # Obtener el servicio seleccionado
    servicio = Servicio.query.get(servicio_id)
    if not servicio:
        return jsonify({'error': 'Servicio no encontrado.'}), 400

    # Obtener el día de la semana en español
    dia_semana_es = ['lunes', 'martes', 'miercoles', 'jueves', 'viernes', 'sabado', 'domingo']
    dia_semana = dia_semana_es[datetime.strptime(fecha, '%Y-%m-%d').weekday()]

    # Obtener el horario de atención para ese día
    horario = horario_atencion.query.filter_by(dia=dia_semana).first()
    if not horario:
        return jsonify({'error': 'No hay horario de atención configurado para este día.'}), 400

    # Convertir las horas de apertura y cierre a objetos datetime
    duracion_servicio = timedelta(minutes=servicio.duracion)
    hora_apertura = datetime.combine(datetime.today(), datetime.strptime(horario.hora_apertura, '%H:%M').time())
    hora_cierre = datetime.combine(datetime.today(), datetime.strptime(horario.hora_cierre, '%H:%M').time())

    # Obtener las citas agendadas para esa fecha
    citas_en_fecha = Cita.query.filter_by(fecha=fecha).all()

    # Guardar las horas ocupadas
    horas_ocupadas = calcular_horas_ocupadas(citas_en_fecha)

    # Generar las horas disponibles
    horas_disponibles = []
    hora_actual = hora_apertura

    while hora_actual + duracion_servicio <= hora_cierre:
        hora_fin = hora_actual + duracion_servicio

        # Comprobar si el intervalo está libre
        if not any(hora_inicio <= hora_actual < hora_fin_ocupada for hora_inicio, hora_fin_ocupada in horas_ocupadas):
            horas_disponibles.append(hora_actual.strftime('%H:%M'))

        # Incrementar el tiempo en intervalos de 15 minutos
        hora_actual += timedelta(minutes=15)

    return jsonify({'horas_disponibles': horas_disponibles})



@app.route('/admin/verificar_fechas', methods=['GET'])
def verificar_fechas():
    fechas = Fecha_disponible.query.all()
    fechas_json = [{'fecha': fecha.fecha, 'dia_semana': fecha.dia_semana, 'disponible': fecha.disponible} for fecha in fechas]
    return jsonify(fechas_json)

if __name__ == '__main__':
    app.run(debug=True)



document.addEventListener('DOMContentLoaded', function() {
    var calendarEl = document.getElementById('calendar');
    console.log(calendarEl);
    var inputFecha = document.getElementById('fecha');
    console.log(inputFecha);
    var calendar = new FullCalendar.Calendar(calendarEl, {
    
        initialView: 'dayGridMonth',
        locale: 'es',  // Configurar el idioma a español
        selectable: true,
        events: function(fetchInfo, successCallback, failureCallback) {
            fetch('/citas')
            .then(response => response.json())
            .then(events => {
                console.log("Eventos cargados:", events);  // Ver los eventos cargados en la consola
                successCallback(events);  // Pasar los eventos a FullCalendar
            })
            .catch(error => {
                console.error("Error cargando los eventos:", error);  // Mostrar el error si ocurre
                failureCallback(error);
            });
        
        },
        
        select: function(info) {
            var eventos = calendar.getEvents();
            console.log("Eventos al seleccionar: ", eventos);  // Asegúrate de que haya eventos cargados
            var disponible = eventos.find(event => event.startStr === info.startStr && event.title === "Disponible");
            console.log("Evento disponible: ", disponible);  // Ver si se encuentra un evento disponible
            if (disponible) {
                inputFecha.value = info.startStr;
                calendarEl.style.display = 'none';
            } else {
                alert("No hay disponibilidad en esta fecha.");
            }
        }
        
    });
    

    // Renderizar el calendario pero mantenerlo oculto
    calendar.render();
    calendarEl.style.display = 'none';
    console.log(calendar);
    console.log(calendarEl);
    // Mostrar el calendario cuando se hace clic en el input de fecha
    inputFecha.addEventListener('focus', function() {
        calendarEl.style.display = 'block';  // Mostrar el calendario
    });
    console.log(calendar.render);
    console.log(calendarEl.style.display);
    console.log(inputFecha);
    console.log(calendarEl);
    // Ocultar el calendario si se hace clic fuera de él
    document.addEventListener('click', function(event) {
        if (!calendarEl.contains(event.target) && event.target !== inputFecha) {
            calendarEl.style.display = 'none';  // Ocultar el calendario si se hace clic fuera
        }
    });
    console.log(document);
    document.getElementById('fecha').addEventListener('change', function() {
        // Código para mostrar las horas disponibles según el servicio y fecha seleccionados
    });
    
});

document.getElementById('fecha').addEventListener('change', function() {
    var fechaSeleccionada = this.value;
    var servicioSeleccionado = document.getElementById('servicio').value;
    console.log(fechaSeleccionada);
    console.log(servicioSeleccionado);
    if (fechaSeleccionada && servicioSeleccionado) {
        fetch('/get_horas_disponibles', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
            },
            body: JSON.stringify({
                fecha: fechaSeleccionada,
                servicio_id: servicioSeleccionado
                
            })
        })
        .then(response => response.json())
        .then(data => {
            var horaSelect = document.getElementById('hora');
            console.log(servicioSeleccionado);
            console.log(fechaSeleccionada);
            console.log(horaSelect);
            console.log(document);
            horaSelect.innerHTML = '';  // Limpiar las opciones actuales

            if (data.horas_disponibles && data.horas_disponibles.length > 0) {
                data.horas_disponibles.forEach(function(hora) {
                    var option = document.createElement('option');
                    option.value = hora;
                    option.textContent = hora;
                    horaSelect.appendChild(option);
                    console.log(data);
                    console.log(option);
                    console.log(horaSelect);
                    console.log(data.horas_disponibles);
                    console.log(hora);
                    console.log(option.textContent);
                    console.log(data.horas_disponibles.length);
                });
            } else {
                alert("No hay horas disponibles para esta fecha.");
            }
        });
    }
});




raíz/templates/index.html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lo de Eli</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
    <link href='https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.css' rel='stylesheet' />
    <script src='https://cdn.jsdelivr.net/npm/fullcalendar@5.10.1/main.min.js'></script>
</head>
<body>
    <div class="banner-container">
        <!--<img src="{{ url_for('static', filename='images/banner.jpeg') }}" alt="Banner" class="banner-image"> -->
        <img src="{{ url_for('static', filename='images/logo.png') }}" alt="Logo" class="logo-image">
    </div>
    <div class="form-container">
        <h1>Agenda tu cita</h1>
        <form action="{{ url_for('agendar') }}" method="post">
            <label for="nombre">Nombre:</label>
            <input type="text" id="nombre" name="nombre" required>

            <label for="email">Email:</label>
            <input type="email" id="email" name="email" required>

            <label for="telefono">Teléfono:</label>
            <input type="tel" id="telefono" name="telefono" required>

            <label for="direccion">Dirección:</label>
            <input type="text" id="direccion" name="direccion" required>

            <label for="cumpleanos">Fecha de Cumpleaños:</label>
            <input type="date" id="cumpleanos" name="cumpleanos" required>

            <label for="servicio">Servicio:</label>
            <select id="servicio" name="servicio" required>
                <option value="Corte de pelo">Corte de pelo</option>
                <option value="Tinte">Tinte</option>
                <option value="Peinado">Peinado</option>
                <option value="Manicura">Manicura</option>
                <option value="Pedicura">Pedicura</option>
            </select>

            <label for="fecha">Fecha:</label>
            <input type="text" id="fecha" name="fecha" readonly required>
            <div id='calendar' style="display:none;"></div>

            <label for="hora">Hora:</label>
            <input type="time" id="hora" name="hora" required>

            <label for="lugar">Lugar del Servicio:</label>
            <select id="lugar" name="lugar" required>
                <option value="Local">En el Local</option>
                <option value="Domicilio">A Domicilio</option>
            </select>

            <label for="pago">Forma de Pago:</label>
            <select id="pago" name="pago" required>
                <option value="Efectivo">Efectivo</option>
                <option value="Transferencia">Transferencia</option>
            </select>

            <div id="transferencia-info" style="display: none;">
                <p>Datos para la transferencia:</p>
                <p>Banco: XXXX</p>
                <p>Cuenta: XXXXXXXX</p>
            </div>

            <button type="submit">Agendar</button>
        </form>
    </div>

    <script src="{{ url_for('static', filename='js/script.js') }}"></script>
</body>
</html>



raíz/templates/confirmacion.html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Confirmación de Cita</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/styles.css') }}">
</head>
<body>
    {% with messages = get_flashed_messages(with_categories=True) %}
        {% if messages %}
            {% for category, message in messages %}
                <div class="alert {{ category }}">
                    <p>{{ message }}</p>
                </div>
            {% endfor %}
        {% endif %}
    {% endwith %}
</body>
</html>



raíz/templates/admin_horarios.html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>Administrar Horarios</title>
</head>
<body>
    <h1>Administrar Horarios de Atención</h1>
    <form method="POST" action="{{ url_for('admin_horarios') }}">
        <label for="dia">Día:</label>
        <select name="dia" id="dia">
            <option value="lunes">Lunes</option>
            <option value="martes">Martes</option>
            <option value="miercoles">Miércoles</option>
            <option value="jueves">Jueves</option>
            <option value="viernes">Viernes</option>
            <option value="sabado">Sábado</option>
            <option value="domingo">Domingo</option>
        </select>
        <label for="hora_apertura">Hora de Apertura:</label>
        <input type="time" name="hora_apertura" id="hora_apertura">
        <label for="hora_cierre">Hora de Cierre:</label>
        <input type="time" name="hora_cierre" id="hora_cierre">
        <button type="submit">Guardar</button>
    </form>

    <h2>Horarios Actuales</h2>
    <ul>
        {% for horario in horarios %}
        <li>{{ horario.dia }}: {{ horario.hora_apertura }} - {{ horario.hora_cierre }}</li>
        {% endfor %}
    </ul>

    <button><a href="{{ url_for('admin') }}">Volver al panel de administración</a></button>
</body>
</html>


raíz/templates/admin.html
<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <script>
        function confirmarCancelacion() {
            return confirm('¿Estás seguro de que deseas cancelar esta cita? Esta acción no se puede deshacer.');
        }
    </script>
    <title>Panel de Administración</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='css/admin_styles.css') }}">
</head>
<body id="bodyadmin">
    <h1>Panel de Administración</h1>
    <button><a href="{{ url_for('admin_servicios') }}">Administrar servicios</a></button><br>
    <button><a href="{{ url_for('admin_horarios') }}">Administrar horarios de atención</a></button>
    <table border="1">
        <thead>
            <tr>
                <th>Cliente</th>
                <th>Email</th>
                <th>Teléfono</th>
                <th>Dirección</th>
                <th>Cumpleaños</th>
                <th>Servicio</th>
                <th>Fecha</th>
                <th>Hora</th>
                <th>Lugar del Servicio</th>
                <th>Forma de Pago</th>
                <th>Acciones</th>
            </tr>
        </thead>
        <tbody>
            {% for cita in citas %}
            <tr>
                <td>{{ cita.cliente.nombre }}</td>
                <td>{{ cita.cliente.email }}</td>
                <td>{{ cita.cliente.telefono }}</td>
                <td>{{ cita.cliente.direccion }}</td>
                <td>{{ cita.cliente.cumpleanos }}</td>
                <td>{{ cita.servicio }}</td>
                <td>{{ cita.fecha }}</td>
                <td>{{ cita.hora }}</td>
                <td>{{ cita.lugar }}</td>
                <td>{{ cita.cliente.pago }}</td>
                <td>
                    <form method="POST" action="{{ url_for('cancelar_cita', id=cita.id) }}" onsubmit="return confirmarCancelacion();">
                        <button type="submit">Cancelar</button>
                    </form>
                </td>
            </tr>
            {% endfor %}
        </tbody>
    </table>
    
</body>
</html>

y este es el contenido de la base de datos: 

Server [localhost]: aws-0-sa-east-1.pooler.supabase.com
Database [postgres]: postgres
Port [5432]: 6543
Username [postgres]: postgres.jfygvbgeqmmrovudkign
Contraseña para usuario postgres.jfygvbgeqmmrovudkign:
psql (16.3, servidor 15.6)
ADVERTENCIA: El código de página de la consola (850) difiere del código
            de página de Windows (1252).
            Los caracteres de 8 bits pueden funcionar incorrectamente.
            Vea la página de referencia de psql «Notes for Windows users»
            para obtener más detalles.
Conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, compresión: desactivado)
Digite «help» para obtener ayuda.

postgres=> \dt;
             Listado de relaciones
 Esquema |      Nombre      | Tipo  |   Due
---------+------------------+-------+----------
 public  | alembic_version  | tabla | postgres
 public  | cita             | tabla | postgres
 public  | cliente          | tabla | postgres
 public  | fecha_disponible | tabla | postgres
 public  | horario_atencion | tabla | postgres
 public  | servicio         | tabla | postgres
(6 filas)


postgres=> SELECT* FROM cita;
 id | cliente_id | servicio | fecha | hora | lugar
----+------------+----------+-------+------+-------
(0 filas)


postgres=> SELECT* FROM cita;
 id | cliente_id | servicio | fecha | hora | lugar
----+------------+----------+-------+------+-------
(0 filas)


postgres=> SELECT* FROM cliente;
 id | nombre | email | telefono | direccion | cumpleanos | lugar | pago
----+--------+-------+----------+-----------+------------+-------+------
(0 filas)


postgres=> SELECT* FROM fecha_disponibles;
ERROR:  relation "fecha_disponibles" does not exist
LÍNEA 1: SELECT* FROM fecha_disponibles;
                     ^
postgres=> SELECT* FROM fecha_disponible;
 id | fecha | dia_semana | disponible
----+-------+------------+------------
(0 filas)


postgres=> SELECT* FROM horario_atencion;
 id |    dia    | hora_apertura | hora_cierre
----+-----------+---------------+-------------
  2 | martes    | 06:00         | 18:00
  3 | miercoles | 06:00         | 18:00
  4 | jueves    | 06:00         | 18:00
  5 | viernes   | 06:00         | 18:00
  6 | sabado    | 15:00         | 23:00
  1 | lunes     | 06:00         | 18:00
  7 | domingo   | 00:00         | 00:00
(7 filas)


postgres=> SELECT* FROM servicio;
 id |    nombre     | duracion
----+---------------+----------
  2 | pedicura      |       45
  3 | peinado       |      120
  4 | manicura      |      120
  5 | tinte         |      180
  6 | corte de pelo |       90
(5 filas)


postgres=> \d fecha_disponible
                                    Tabla ½public.fecha_disponible╗
  Columna   |         Tipo          | Ordenamiento | Nulable  |                  Por omisi
------------+-----------------------+--------------+----------+----------------------------------------------
 id         | integer               |              | not null | nextval('fecha_disponible_id_seq'::regclass)
 fecha      | character varying(10) |              | not null |
 dia_semana | character varying(10) |              | not null |
 disponible | boolean               |              |          |
═ndices:
    "fecha_disponible_pkey" PRIMARY KEY, btree (id)


postgres=> SELECT * FROM fecha_disponible;
 id | fecha | dia_semana | disponible
----+-------+------------+------------
(0 filas)


postgres=> INSERT INTO fecha_disponible (fecha, dia_semana, disponible) VALUES
postgres-> ('2024-08-16', 'viernes', TRUE),
postgres-> ('2024-08-17', 'sábado', FALSE),
postgres-> ('2024-08-18', 'domingo', TRUE);
la conexión SSL se ha cerrado inesperadamente
La conexión al servidor se ha perdido. Intentando reiniciar: Con éxito.
psql (16.3, servidor 15.6)
Conexión SSL (protocolo: TLSv1.3, cifrado: TLS_AES_256_GCM_SHA384, compresión: desactivado)
postgres=> INSERT INTO fecha_disponible (fecha, dia_semana, disponible) VALUES
postgres-> ('2024-08-16', 'viernes', TRUE),
postgres-> ('2024-08-17', 'sabado', FALSE),
postgres-> ('2024-08-18', 'domingo', TRUE);
INSERT 0 3
postgres=> SELECT * FROM fecha_disponible;
 id |   fecha    | dia_semana | disponible
----+------------+------------+------------
  1 | 2024-08-16 | viernes    | t
  2 | 2024-08-17 | sabado     | f
  3 | 2024-08-18 | domingo    | t
(3 filas)


postgres=> SELECT * FROM fecha_disponible;
 id |   fecha    | dia_semana | disponible
----+------------+------------+------------
  1 | 2024-08-16 | viernes    | t
  2 | 2024-08-17 | sabado     | f
  3 | 2024-08-18 | domingo    | t
(3 filas)


postgres=>


como verás he insertado datos directamente desde la base de datos a la tabla fecha_disponible y de esa manera figuran como disponibles los dias 16, 17 y 18 de agosto, de otra forma no están ingresando los datos a esa tabla, y deberían ingresar automaticamente basandose en las tablas de horario_atencion, servicio, y cita luego de calcular en que fechas aún hay espacio.